<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>FHQ Treap 详解</title>
    <url>/posts/1918694436/</url>
    <content><![CDATA[<h1 id="1）FHQ-Treap-基本功能理论与实现"><a href="#1）FHQ-Treap-基本功能理论与实现" class="headerlink" title="1）FHQ-Treap 基本功能理论与实现"></a>1）FHQ-Treap 基本功能理论与实现</h1><p>不同于经典的基于<a href="https://blog.csdn.net/zhaochuanfei666/article/details/110518539">左旋、右旋的 Treap</a>，FHQ-Treap 是基于分裂与合并的的一种 Treap。虽然两者操作方式完全不同，但产生的结果是一样的。而且，FHQ-Treap 具有<strong>好写</strong>（打板子超快）、<strong>好理解</strong>（左旋右旋我到现在还没搞明白）以及可持久化、区间翻转、移动等等一大坨优点。</p>
<p>（%%% FHQ 大佬）</p>
<span id="more"></span>
<p>接下来会详细介绍 FHQ-Treap。</p>
<h2 id="1-1）FHQ-Treap-模型"><a href="#1-1）FHQ-Treap-模型" class="headerlink" title="1.1）FHQ-Treap 模型"></a>1.1）FHQ-Treap 模型</h2><p>首先，它是一个 <strong>Treap</strong>；其次，它是一个基于<strong>分裂+合并</strong>的 Treap。</p>
<p>比如，可以通过创建一个只有根节点的 Treap，然后再和原来的 Treap 合并，这就是插入节点。</p>
<p>再比如，可以通过分裂开 Treap，把某个节点分离开，合并其他的节点，这就是删除节点。</p>
<p>……如此好用、好理解的 FHQ-Treap 如何实现呢？</p>
<p>Treap 的话就不多说了，可以参考上面的博客；那么如何在<strong>分裂+合并</strong>操作中维护这个 Treap 呢？</p>
<p>众所周知，Treap 要维护的无非两点：</p>
<ol>
<li><p>键值（key），满足 $左儿子键值 \leq 该节点键值 \leq 右儿子键值$</p>
</li>
<li><p>优先级（pri），满足 $左儿子优先级或右儿子的优先级 \leq 该节点的优先级$</p>
</li>
</ol>
<p>我们需要在分裂操作与合并操作中根据这两点对 Treap 进行维护（因为其他操作都建立在这两个操作上）。</p>
<p>我们定义一个结构体，记录 Treap 上每个点的信息。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> lsn,rsn;</span><br><span class="line">    <span class="type">int</span> key,pri,siz;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> tSize=<span class="number">0</span>,root=<span class="number">0</span>;</span><br><span class="line">Node treap[MS];</span><br></pre></td></tr></table></figure>
<p>其中 <code>tSize</code> 是节点个数，<code>root</code> 是 Treap 的根。这里使用了数组的方式存储 Treap。</p>
<h2 id="1-2）操作一：分裂（Split）"><a href="#1-2）操作一：分裂（Split）" class="headerlink" title="1.2）操作一：分裂（Split）"></a>1.2）操作一：分裂（Split）</h2><p>Split 需要考虑四个参数，分别是当前遍历到的节点、分裂的标准、传递回的两棵树的根。</p>
<p>一般，Split 都是讲某个 Treap 分裂成一个小于等于某值的 Treap，一个大于该值的 Treap。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x,<span class="type">int</span> &amp;L,<span class="type">int</span> &amp;R)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中很妙的一点，$L$ 与 $R$ 都传递了它的地址，即可通过该操作修改某个 Treap 的左子树、右子树信息或传递回分裂开的两个 Treap 的编号。这一点在后面的应用中<strong>十分重要</strong>。</p>
<p>那么如何分裂呢？</p>
<p><img src="https://linkcattree.github.io/images/FHQ_Treap_0.jpg" alt=""></p>
<p>（这里分裂的操作并不用到优先级，节点上的值都是键值）</p>
<p>很明显的可以看出：</p>
<ul>
<li><p>当目前枚举到的 Treap 的根要<strong>小于等于分裂标准</strong>时，其<strong>左子树都必然小于等于分裂标准</strong>，只用考虑右子树；</p>
</li>
<li><p>反之，当目前 Treap 的根要<strong>大于分裂标准是</strong>，其<strong>右子树必然都大于分裂标准</strong>，只用考虑左子树。</p>
</li>
</ul>
<p>所以，代码就很明显了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x,<span class="type">int</span> &amp;L,<span class="type">int</span> &amp;R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==<span class="number">0</span>) &#123;</span><br><span class="line">        L=R=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(treap[u].key&lt;=x) L=u,<span class="built_in">split</span>(treap[u].rsn,x,treap[u].rsn,R);</span><br><span class="line">    <span class="keyword">else</span> R=u,<span class="built_in">split</span>(treap[u].lsn,x,L,treap[u].lsn);</span><br><span class="line">    <span class="built_in">updateRoot</span>(u);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 Split 的时间复杂度就是树高，所以它的期望时间复杂度为 $\mathcal{O}(\log_2^n)$</p>
<h2 id="1-3）操作二：合并（Merge）"><a href="#1-3）操作二：合并（Merge）" class="headerlink" title="1.3）操作二：合并（Merge）"></a>1.3）操作二：合并（Merge）</h2><p>划重点：<strong>Merge 的性质：Merge 要满足合并的两个 Treap （用根 L 与 R 表示），L 中的值都小于等于 R！</strong></p>
<p>合并的时候，就要考虑优先值了。先比较两颗 Treap 的根节点的优先值大小。如果 L 大，把 R 合并到 L 的右子树上去；否则，把 L 合并到 R 的左子树上去（因为 L 中的值都小于 R）。最终，Merge 要返回合并后的根。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="number">0</span>||R==<span class="number">0</span>) <span class="keyword">return</span> L+R;</span><br><span class="line">    <span class="keyword">if</span>(treap[L].pri&gt;treap[R].pri) &#123;</span><br><span class="line">        treap[L].rsn=<span class="built_in">merge</span>(treap[L].rsn,R);</span><br><span class="line">        <span class="built_in">updateRoot</span>(L);</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        treap[R].lsn=<span class="built_in">merge</span>(L,treap[R].lsn);</span><br><span class="line">        <span class="built_in">updateRoot</span>(R);</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺便说一下 <code>updateRoot</code>。用来更新某个节点为根的 Treap 的大小（求排名什么的要用到）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateRoot</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    treap[u].siz=treap[treap[u].lsn].siz+treap[treap[u].rsn].siz<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同上，期望时间复杂度 $\mathcal{O}(\log_2^n)$</p>
<p>$P.S.$ 到目前为止，FHQ-Treap 最难的部分都已经被你搞明白啦！剩下的都很简单的啦！</p>
<h2 id="1-4）操作三：插入新节点"><a href="#1-4）操作三：插入新节点" class="headerlink" title="1.4）操作三：插入新节点"></a>1.4）操作三：插入新节点</h2><p>这很简单，首先创建一个只有一个节点的 Treap：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeNewNode</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    ++tSize;</span><br><span class="line">    treap[tSize].siz=<span class="number">1</span>;</span><br><span class="line">    treap[tSize].lsn=treap[tSize].rsn=<span class="number">0</span>;</span><br><span class="line">    treap[tSize].key=x,treap[tSize].pri=<span class="built_in">rand</span>();</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再把这个 Treap 合并到大 Treap 上：（注意 <strong>Merge 的性质</strong>，所以要先分裂）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> L,R;</span><br><span class="line">    <span class="built_in">split</span>(root,x,L,R);</span><br><span class="line">    <span class="built_in">makeNewNode</span>(x);</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(L,tSize),R);</span><br><span class="line">    <span class="keyword">return</span> tSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-5）删除某个节点"><a href="#1-5）删除某个节点" class="headerlink" title="1.5）删除某个节点"></a>1.5）删除某个节点</h2><p>这里假设只删除一个与查询的值相通的节点。</p>
<p>先分裂出一颗全是要删除的值的 Treap，然后把这个 Treap 的左子树与右子树进行合并（把根丢掉），实现该操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">delNum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> L,M,R;</span><br><span class="line">    <span class="built_in">split</span>(root,x,L,R);</span><br><span class="line">    <span class="built_in">split</span>(L,x<span class="number">-1</span>,L,M);</span><br><span class="line">    M=<span class="built_in">merge</span>(treap[M].lsn,treap[M].rsn);</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(L,M),R);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，如果你要一次性删除所有值为 $x$ 的节点，可以这么写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">delNum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> L,M,R;</span><br><span class="line">    <span class="built_in">split</span>(root,x,L,R);</span><br><span class="line">    <span class="built_in">split</span>(L,x<span class="number">-1</span>,L,M);</span><br><span class="line">    root=<span class="built_in">merge</span>(L,R);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-6）查询某个值的排名"><a href="#1-6）查询某个值的排名" class="headerlink" title="1.6）查询某个值的排名"></a>1.6）查询某个值的排名</h2><p>不说了，把小于 $x$ 的分裂出来，它的大小加一。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRank</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> L,R,res;</span><br><span class="line">    <span class="built_in">split</span>(root,x<span class="number">-1</span>,L,R);</span><br><span class="line">    res=treap[L].siz<span class="number">+1</span>;</span><br><span class="line">    root=<span class="built_in">merge</span>(L,R);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-7）查询排名为-k-的值"><a href="#1-7）查询排名为-k-的值" class="headerlink" title="1.7）查询排名为 $k$ 的值"></a>1.7）查询排名为 $k$ 的值</h2><p>很好理解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==treap[treap[u].lsn].siz<span class="number">+1</span>) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=treap[treap[u].lsn].siz) <span class="keyword">return</span> <span class="built_in">kth</span>(treap[u].lsn,k);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">kth</span>(treap[u].rsn,k-treap[treap[u].lsn].siz<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-8）查询-x-的前驱与后继"><a href="#1-8）查询-x-的前驱与后继" class="headerlink" title="1.8）查询 $x$ 的前驱与后继"></a>1.8）查询 $x$ 的前驱与后继</h2><p>见代码。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前驱</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">precursor</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> L,R,res;</span><br><span class="line">    <span class="built_in">split</span>(root,x<span class="number">-1</span>,L,R);</span><br><span class="line">    res=treap[<span class="built_in">kth</span>(L,treap[L].siz)].key;</span><br><span class="line">    root=<span class="built_in">merge</span>(L,R);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后继</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">successor</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> L,R,res;</span><br><span class="line">    <span class="built_in">split</span>(root,x,L,R);</span><br><span class="line">    res=treap[<span class="built_in">kth</span>(R,<span class="number">1</span>)].key;</span><br><span class="line">    root=<span class="built_in">merge</span>(L,R);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-9）End-of-this-unit"><a href="#1-9）End-of-this-unit" class="headerlink" title="1.9）End of this unit"></a>1.9）End of this unit</h2><p>以上就是所有 FHQ-Treap 的基本操作，接下来讲几个应用。</p>
<h1 id="2）FHQ-Treap-的应用"><a href="#2）FHQ-Treap-的应用" class="headerlink" title="2）FHQ-Treap 的应用"></a>2）FHQ-Treap 的应用</h1><h2 id="2-1）洛谷-P3369"><a href="#2-1）洛谷-P3369" class="headerlink" title="2.1）洛谷 P3369"></a>2.1）洛谷 P3369</h2><p>不说，套板子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MS=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> lsn,rsn;</span><br><span class="line">    <span class="type">int</span> key,pri,siz;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> tSize=<span class="number">0</span>,root=<span class="number">0</span>;</span><br><span class="line">Node treap[MS];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeNewNode</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    ++tSize;</span><br><span class="line">    treap[tSize].siz=<span class="number">1</span>;</span><br><span class="line">    treap[tSize].lsn=treap[tSize].rsn=<span class="number">0</span>;</span><br><span class="line">    treap[tSize].key=x,treap[tSize].pri=<span class="built_in">rand</span>();</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateRoot</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    treap[u].siz=treap[treap[u].lsn].siz+treap[treap[u].rsn].siz<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x,<span class="type">int</span> &amp;L,<span class="type">int</span> &amp;R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==<span class="number">0</span>) &#123;</span><br><span class="line">        L=R=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(treap[u].key&lt;=x) L=u,<span class="built_in">split</span>(treap[u].rsn,x,treap[u].rsn,R);</span><br><span class="line">    <span class="keyword">else</span> R=u,<span class="built_in">split</span>(treap[u].lsn,x,L,treap[u].lsn);</span><br><span class="line">    <span class="built_in">updateRoot</span>(u);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="number">0</span>||R==<span class="number">0</span>) <span class="keyword">return</span> L+R;</span><br><span class="line">    <span class="keyword">if</span>(treap[L].pri&gt;treap[R].pri) &#123;</span><br><span class="line">        treap[L].rsn=<span class="built_in">merge</span>(treap[L].rsn,R);</span><br><span class="line">        <span class="built_in">updateRoot</span>(L);</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        treap[R].lsn=<span class="built_in">merge</span>(L,treap[R].lsn);</span><br><span class="line">        <span class="built_in">updateRoot</span>(R);</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> L,R;</span><br><span class="line">    <span class="built_in">split</span>(root,x,L,R);</span><br><span class="line">    <span class="built_in">makeNewNode</span>(x);</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(L,tSize),R);</span><br><span class="line">    <span class="keyword">return</span> tSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">delNum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> L,M,R;</span><br><span class="line">    <span class="built_in">split</span>(root,x,L,R);</span><br><span class="line">    <span class="built_in">split</span>(L,x<span class="number">-1</span>,L,M);</span><br><span class="line">    M=<span class="built_in">merge</span>(treap[M].lsn,treap[M].rsn);</span><br><span class="line">    root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(L,M),R);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getRank</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> L,R,res;</span><br><span class="line">    <span class="built_in">split</span>(root,x<span class="number">-1</span>,L,R);</span><br><span class="line">    res=treap[L].siz<span class="number">+1</span>;</span><br><span class="line">    root=<span class="built_in">merge</span>(L,R);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==treap[treap[u].lsn].siz<span class="number">+1</span>) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=treap[treap[u].lsn].siz) <span class="keyword">return</span> <span class="built_in">kth</span>(treap[u].lsn,k);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">kth</span>(treap[u].rsn,k-treap[treap[u].lsn].siz<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">precursor</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> L,R,res;</span><br><span class="line">    <span class="built_in">split</span>(root,x<span class="number">-1</span>,L,R);</span><br><span class="line">    res=treap[<span class="built_in">kth</span>(L,treap[L].siz)].key;</span><br><span class="line">    root=<span class="built_in">merge</span>(L,R);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">successor</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> L,R,res;</span><br><span class="line">    <span class="built_in">split</span>(root,x,L,R);</span><br><span class="line">    res=treap[<span class="built_in">kth</span>(R,<span class="number">1</span>)].key;</span><br><span class="line">    root=<span class="built_in">merge</span>(L,R);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        <span class="type">int</span> opt,x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;opt,&amp;x);</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">2</span>) <span class="built_in">delNum</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">getRank</span>(x));</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,treap[<span class="built_in">kth</span>(root,x)].key);</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">5</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">precursor</span>(x));</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">successor</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-1）洛谷-P3391"><a href="#2-1）洛谷-P3391" class="headerlink" title="2.1）洛谷 P3391"></a>2.1）洛谷 P3391</h2><p>翻转参考线段树的 <code>lazy_tag</code>。分裂的时候要稍微改一下，和查询排名一样。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MS=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> lsn,rsn;</span><br><span class="line">    <span class="type">int</span> key,pri,siz;</span><br><span class="line">    <span class="type">int</span> lazy;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> tSize=<span class="number">0</span>,root=<span class="number">0</span>;</span><br><span class="line">Node treap[MS];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeNewNode</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    ++tSize;</span><br><span class="line">    treap[tSize].siz=<span class="number">1</span>;</span><br><span class="line">    treap[tSize].lazy=treap[tSize].lsn=treap[tSize].rsn=<span class="number">0</span>;</span><br><span class="line">    treap[tSize].key=x,treap[tSize].pri=<span class="built_in">rand</span>();</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">updateRoot</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    treap[u].siz=treap[treap[u].lsn].siz+treap[treap[u].rsn].siz<span class="number">+1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushDown</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(treap[u].lazy) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(treap[u].lsn,treap[u].rsn);</span><br><span class="line">        treap[treap[u].lsn].lazy^=<span class="number">1</span>;</span><br><span class="line">        treap[treap[u].rsn].lazy^=<span class="number">1</span>;</span><br><span class="line">        treap[u].lazy=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">split</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> x,<span class="type">int</span> &amp;L,<span class="type">int</span> &amp;R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==<span class="number">0</span>) &#123;</span><br><span class="line">        L=R=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushDown</span>(u);</span><br><span class="line">    <span class="keyword">if</span>(treap[treap[u].lsn].siz<span class="number">+1</span>&lt;=x)</span><br><span class="line">        L=u,<span class="built_in">split</span>(treap[u].rsn,x-treap[treap[u].lsn].siz<span class="number">-1</span>,treap[u].rsn,R);</span><br><span class="line">    <span class="keyword">else</span> R=u,<span class="built_in">split</span>(treap[u].lsn,x,L,treap[u].lsn);</span><br><span class="line">    <span class="built_in">updateRoot</span>(u);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> L,<span class="type">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L==<span class="number">0</span>||R==<span class="number">0</span>) <span class="keyword">return</span> L+R;</span><br><span class="line">    <span class="keyword">if</span>(treap[L].pri&gt;treap[R].pri) &#123;</span><br><span class="line">        <span class="built_in">pushDown</span>(L);</span><br><span class="line">        treap[L].rsn=<span class="built_in">merge</span>(treap[L].rsn,R);</span><br><span class="line">        <span class="built_in">updateRoot</span>(L);</span><br><span class="line">        <span class="keyword">return</span> L;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">pushDown</span>(R);</span><br><span class="line">        treap[R].lsn=<span class="built_in">merge</span>(L,treap[R].lsn);</span><br><span class="line">        <span class="built_in">updateRoot</span>(R);</span><br><span class="line">        <span class="keyword">return</span> R;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u==<span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">pushDown</span>(u);</span><br><span class="line">    <span class="built_in">inorder</span>(treap[u].lsn);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,treap[u].key);</span><br><span class="line">    <span class="built_in">inorder</span>(treap[u].rsn);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">makeNewNode</span>(i),root=<span class="built_in">merge</span>(root,tSize);</span><br><span class="line">    <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">        <span class="type">int</span> L,R,mid;</span><br><span class="line">        <span class="built_in">split</span>(root,r,L,R);</span><br><span class="line">        <span class="built_in">split</span>(L,l<span class="number">-1</span>,L,mid);</span><br><span class="line">        treap[mid].lazy^=<span class="number">1</span>;</span><br><span class="line">        root=<span class="built_in">merge</span>(<span class="built_in">merge</span>(L,mid),R);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">inorder</span>(root);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="END"><a href="#END" class="headerlink" title="END"></a>END</h1><p>还有几个应用没更新……我懒狗，等以后吧</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>洛谷 P10102 题解</title>
    <url>/posts/3883134504/</url>
    <content><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P10102">题目传送门</a>。</p>
<p>发现直接判断 $A \times B=C$ 是 $\mathcal{O}(n^3)$ 的，我们可以在式子两边同时乘上一个 $1 \times n$ 的矩阵 $D$：$D \times A \times B = D \times C$（注意顺序）。这里共有三次矩阵乘法，复杂度均为 $\mathcal{O}(n^2)$。为提高正确率，$D$ 矩阵可采用随机生成。</p>
<span id="more"></span>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> T,n;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ch=<span class="built_in">getchar</span>(),minus=<span class="number">0</span>; ll x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) minus|=(ch==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span>(;ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>;ch=<span class="built_in">getchar</span>()) x=x*<span class="number">10</span>+(ch^<span class="number">48</span>);</span><br><span class="line">    <span class="keyword">return</span> minus?-x:x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">3005</span>; </span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line">ll a[N][N],b[N][N],c[N][N],d[<span class="number">2</span>][N],e[<span class="number">2</span>][N],f[<span class="number">2</span>][N],g[<span class="number">2</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T),<span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) a[i][j]=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) b[i][j]=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) c[i][j]=<span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) d[<span class="number">1</span>][i]=<span class="built_in">rand</span>(),e[<span class="number">1</span>][i]=f[<span class="number">1</span>][i]=g[<span class="number">1</span>][i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) e[<span class="number">1</span>][i]=(e[<span class="number">1</span>][i]+d[<span class="number">1</span>][j]*a[j][i]%mod)%mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) f[<span class="number">1</span>][i]=(f[<span class="number">1</span>][i]+e[<span class="number">1</span>][j]*b[j][i]%mod)%mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) g[<span class="number">1</span>][i]=(g[<span class="number">1</span>][i]+d[<span class="number">1</span>][j]*c[j][i]%mod)%mod;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">if</span>(f[<span class="number">1</span>][i]!=g[<span class="number">1</span>][i]) &#123;</span><br><span class="line">                flag=<span class="literal">false</span>; <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>总时间复杂度 $\mathcal{O}(Tn^2)$，空间复杂度 $\mathcal{O}(n^2)$，<a href="https://www.luogu.com.cn/record/186882036">实际表现</a>。</p>
<p>不要抄袭，我们共建新洛谷。</p>
]]></content>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>test</title>
    <url>/posts/3632233996/</url>
    <content><![CDATA[<h1 id="H1"><a href="#H1" class="headerlink" title="H1"></a>H1</h1><h2 id="H2"><a href="#H2" class="headerlink" title="H2"></a>H2</h2><h3 id="H3"><a href="#H3" class="headerlink" title="H3"></a>H3</h3><h4 id="H4"><a href="#H4" class="headerlink" title="H4"></a>H4</h4><h5 id="H5"><a href="#H5" class="headerlink" title="H5"></a>H5</h5><h2 id="Highlight"><a href="#Highlight" class="headerlink" title="Highlight"></a>Highlight</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Hello World&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LaTeX"><a href="#LaTeX" class="headerlink" title="LaTeX"></a>LaTeX</h2><p>$x=\frac{-b \pm \sqrt{b^2-4ac}}{2a}$</p>
<h2 id="Markdown"><a href="#Markdown" class="headerlink" title="Markdown"></a>Markdown</h2><p><strong>粗体</strong>_斜体_<strong><em>又粗又斜</em></strong><del>划掉</del>。</p>
]]></content>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
</search>
